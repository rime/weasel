#include "stdafx.h"

#include <PipeChannel.h>

using namespace weasel;
using namespace std;
using namespace boost;

#define _ThrowLastError throw ::GetLastError()
#define _ThrowCode(__c) throw __c
#define _ThrowIfNot(__c) { DWORD err; if ((err = ::GetLastError()) != __c) throw __c; }

PipeChannelBase::PipeChannelBase(std::wstring &pn_cmd, size_t bs = 4 * 1024, SECURITY_ATTRIBUTES *s = NULL)
	: pname(pn_cmd),
	write_stream(nullptr),
	buff_size(bs),
	buffer(std::make_unique<char[]>(bs)),
	hpipe(INVALID_HANDLE_VALUE),
	has_body(false),
	sa(s) {};

PipeChannelBase::PipeChannelBase(PipeChannelBase &&r)
	: write_stream(std::move(r.write_stream)),
	pname(std::move(r.pname)),
	buff_size(r.buff_size),
	buffer(std::move(r.buffer)),
	hpipe(r.hpipe),
	has_body(r.has_body),
	sa(r.sa) {};


PipeChannelBase::~PipeChannelBase()
{
	_FinalizePipe(hpipe);
}

bool PipeChannelBase::_Ensure()
{
	try {
		if (_Invalid(hpipe)) {
			hpipe = _Connect(pname.c_str());
			return !_Invalid(hpipe);
		}
	}
	catch (...) {
		return false;
	}

	return true;
}

HANDLE PipeChannelBase::_Connect(const wchar_t *name)
{
	HANDLE pipe = INVALID_HANDLE_VALUE;
	while (_Invalid(pipe = _TryConnect()))
		::WaitNamedPipe(name, 500);
	DWORD mode = PIPE_READMODE_MESSAGE;
	if (!SetNamedPipeHandleState(pipe, &mode, NULL, NULL)) {
		_ThrowLastError;
	}
	return pipe;
}

void PipeChannelBase::_Reconnect()
{
	_FinalizePipe(hpipe);
	_Ensure();
}

HANDLE PipeChannelBase::_TryConnect()
{
	auto pipe = ::CreateFile(pname.c_str(), GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (!_Invalid(pipe)) {
		// connected to the pipe
		return pipe;
	}
	// being busy is not really an error since we just need to wait.
	_ThrowIfNot(ERROR_PIPE_BUSY);
	// All pipe instances are busy
	return INVALID_HANDLE_VALUE;
}

size_t PipeChannelBase::_WritePipe(HANDLE pipe, size_t s, char *b)
{
	DWORD lwritten;
	if (!::WriteFile(pipe, b, s, &lwritten, NULL) || lwritten <= 0) {
		_ThrowLastError;
	}
	::FlushFileBuffers(pipe);
	return lwritten;
}

void PipeChannelBase::_FinalizePipe(HANDLE &p)
{
	if (!_Invalid(p)) {
		DisconnectNamedPipe(p);
		CloseHandle(p);
	}
	p = INVALID_HANDLE_VALUE;
}

void PipeChannelBase::_Receive(HANDLE pipe, LPVOID msg, size_t rec_len)
{
	DWORD lread;
	BOOL success = ::ReadFile(pipe, msg, rec_len, &lread, NULL);
	if (!success) {
		_ThrowIfNot(ERROR_MORE_DATA);

		memset(buffer.get(), 0, buff_size);
		success = ::ReadFile(pipe, buffer.get(), buff_size, &lread, NULL);
		if (!success) {
			_ThrowLastError;
		}
	}
	has_body = false;
}

HANDLE PipeChannelBase::_ConnectServerPipe(std::wstring &pn)
{
	HANDLE pipe = CreateNamedPipe(
		pn.c_str(),
		PIPE_ACCESS_DUPLEX,
		PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
		PIPE_UNLIMITED_INSTANCES,
		buff_size,
		buff_size,
		0,
		sa);
	if (pipe == INVALID_HANDLE_VALUE || !::ConnectNamedPipe(pipe, NULL)) {
		_ThrowLastError;
	}
	return pipe;
}

